//! Console input and output.

use core::fmt::{Arguments, Result, Write};

/// Console input and output interface.
#[def_plat_interface]
pub trait ConsoleIf {
    /// Writes given bytes to the console.
    fn write_bytes(bytes: &[u8]);

    /// Writes given bytes to the console **without any global/driver locks**.
    ///
    /// This interface is intended for emergency situations where taking locks
    /// may deadlock or is not allowed, e.g. in NMI/pseudo-NMI watchdog handlers
    /// or during a panic while another CPU/task is holding the console lock.
    ///
    /// # Semantics
    /// - Best-effort: output may be interleaved or partially lost.
    /// - No ordering/atomicity guarantee across CPUs.
    /// - Platform implementations should avoid grabbing any locks.
    ///
    /// The default implementation falls back to [`ConsoleIf::write_bytes`].
    #[inline]
    fn write_bytes_force(bytes: &[u8]) {
        Self::write_bytes(bytes)
    }

    /// Reads bytes from the console into the given mutable slice.
    ///
    /// Returns the number of bytes read.
    fn read_bytes(bytes: &mut [u8]) -> usize;

    /// Returns the IRQ number for the console input interrupt.
    ///
    /// Returns `None` if input interrupt is not supported.
    #[cfg(feature = "irq")]
    fn irq_num() -> Option<usize>;
}

struct EarlyConsole;

impl Write for EarlyConsole {
    fn write_str(&mut self, s: &str) -> Result {
        write_bytes(s.as_bytes());
        Ok(())
    }
}

struct ForceConsole;

impl Write for ForceConsole {
    fn write_str(&mut self, s: &str) -> Result {
        write_bytes_force(s.as_bytes());
        Ok(())
    }
}

/// Lock for console operations to prevent mixed output from concurrent execution
pub static CONSOLE_LOCK: kspin::SpinNoIrq<()> = kspin::SpinNoIrq::new(());

/// Simple console print operation.
#[macro_export]
macro_rules! console_print {
    ($($arg:tt)*) => {
        $crate::console::__simple_print(format_args!($($arg)*));
    }
}

/// Simple console print operation, with a newline.
#[macro_export]
macro_rules! console_println {
    () => { $crate::ax_print!("\n") };
    ($($arg:tt)*) => {
        $crate::console::__simple_print(format_args!("{}\n", format_args!($($arg)*)));
    }
}

#[doc(hidden)]
pub fn __simple_print(fmt: Arguments) {
    let _guard = CONSOLE_LOCK.lock();
    EarlyConsole.write_fmt(fmt).unwrap();
    drop(_guard);
}

/// Force console print operation.
///
/// Unlike [`__simple_print`], this function does **not** acquire
/// [`CONSOLE_LOCK`]. It is intended for emergency printing.
#[doc(hidden)]
pub fn __force_print(fmt: Arguments) {
    ForceConsole.write_fmt(fmt).ok();
}

/// Force console print operation.
#[macro_export]
macro_rules! console_force_print {
    ($($arg:tt)*) => {
        $crate::console::__force_print(core::format_args!($($arg)*));
    }
}

/// Force console print operation, with a newline.
#[macro_export]
macro_rules! console_force_println {
    () => { $crate::console_force_print!("\n") };
    ($($arg:tt)*) => {
        $crate::console::__force_print(core::format_args!("{}\n", core::format_args!($($arg)*)));
    }
}
